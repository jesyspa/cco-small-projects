module{AG.StronglyLiveVariable}{}{}

{
import AG.AttributeGrammar
import qualified Data.Map as M
import qualified Data.Set as S
}

include "AttributeGrammar.ag"

{
type SLVData = S.Set String
type Vars = M.Map Int SLVData
}

attr Program' Procs' Proc' Stat'
    syn gens use {`M.union`} {M.empty} :: {Vars}
    -- Strictly speaking, we could use an M.Map Int String for kills, since
    -- every statement kills at most one variable.
    syn kills use {`M.union`} {M.empty} :: {Vars}

attr IExpr BExpr
    syn uses use {`S.union`} {S.empty} :: {SLVData}


sem Stat'
    | IfThenElse' While'
                       +gens = M.insert @labelc @cond.uses
    | IAssign' BAssign' Malloc'
                    lhs.kills   = M.singleton @label (S.singleton @name)
    | IAssign' BAssign'
                    lhs.gens    = M.singleton @label @val.uses
    | Malloc'
                    lhs.gens    = M.singleton @label @size.uses

sem IExpr
    | Var           lhs.uses   = S.singleton @name

sem BExpr
    | BVar          lhs.uses   = S.singleton @name
