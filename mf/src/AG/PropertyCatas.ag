module{AG.PropertyCatas}{}{}

{
import Prelude hiding (init)
import AG.AttributeGrammar
import qualified Data.Set as S
import qualified Data.Map as M
}

include "AttributeGrammar.ag"

attr Program' Proc' Stat'
    syn     init :: {Int}
    syn     final use {++} {error "undefined finals"} :: {[Int]}
    syn     labels use {++} {error "undefined labels"} :: {[Int]}

attr Procs'
    syn     labels use {++} {[]} :: {[Int]}

attr Procs' Proc'
    syn     plabels use {`M.union`} {M.empty} :: {M.Map String (Int, Int)}

attr Procs' Proc' Stat'
    inh     plabels' :: {M.Map String (Int, Int)}

attr Program' Procs' Proc' Stat'
    syn     flow use {++} {[]} :: {[(Int, Int)]}

attr Program' Proc' Procs' Stat' IExpr BExpr Exprs Expr
    syn     names use {`S.union`} {S.empty} :: {S.Set String}
    syn     copy :: self

sem Program'
  | Program'      lhs.init       = @stat.init
                  lhs.final      = @stat.final
                  stat .plabels' = @procs.plabels
                  procs.plabels' = @procs.plabels

sem Proc'
  | Proc'         lhs.init       = @labelEntry
                  lhs.final      = [@labelReturn]
                     +labels     = (++) [@labelEntry, @labelReturn]
                     +flow       = (++) $ [(@labelEntry, @stat.init)] ++ [(l, @labelReturn) | l <- @stat.final]
                  lhs.plabels    = M.singleton @name (@labelEntry, @labelReturn)

sem Stat'
  | Skip' IAssign' BAssign' Continue' Break'
                  lhs.init       = @label
                  lhs.final      = [@label]
                  lhs.labels     = [@label]
  | IAssign' BAssign'
                  lhs.names      = S.singleton @name
  | IfThenElse' While'
                  lhs.init       = @labelc
                     +labels     = (:) @labelc
  | IfThenElse'      +flow       = (++) [(@labelc, @stat1.init), (@labelc, @stat2.init)]
  | While'        lhs.final      = [@labelc]
                     +flow       = (++) $ [(@labelc, @stat.init)] ++ [(x, @labelc) | x <- @stat.final]
  | Seq'             +flow       = (++) [(x, @stat2.init) | x <- @stat1.final]
                  lhs.final      = @stat2.final
                  lhs.init       = @stat1.init
  | Call'         lhs.init       = @labelCall
                  lhs.final      = [@labelExit]
                  lhs.labels     = [@labelCall, @labelExit]
                  loc.funLabels  = @lhs.plabels' M.! @name
                  lhs.flow       = [(@labelCall, fst @loc.funLabels), (snd @loc.funLabels, @labelExit)]

sem IExpr
  | Var           lhs.names      = S.singleton @name

sem BExpr
  | BVar          lhs.names      = S.singleton @name


{
run s = wrap_Program' (sem_Program' s) Inh_Program'

-- I was sorely tempted to use Template Haskell for this bit, but I thought your day might be bad enough without that.
init :: Program' -> Int
init = init_Syn_Program' . run

final :: Program' -> [Int]
final = final_Syn_Program' . run

labels :: Program' -> [Int]
labels = labels_Syn_Program' . run

flow :: Program' -> [(Int, Int)]
flow = flow_Syn_Program' . run

flowR :: Program' -> [(Int, Int)]
flowR = map (uncurry $ flip (,)) . flow

names :: Program' -> S.Set String
names prog = names_Syn_Program' $ wrap_Program' (sem_Program' prog) Inh_Program'

}
