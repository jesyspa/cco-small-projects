module{AG.PropertyCatas}{}{}

{
import Prelude hiding (init)
import AG.AttributeGrammar
import qualified Data.Set as S
}

include "AttributeGrammar.ag"

attr Program' Proc' Procs'
    syn     names use {`S.union`} {S.empty} :: {S.Set String}

attr Stat'
    syn     init :: {Int}
    syn     final use {++} {undefined} :: {[Int]}
    syn     blocks use {++} {undefined} :: {[Code]}
    syn     labels use {++} {undefined} :: {[Int]}
    syn     flow use {++} {[]} :: {[(Int, Int)]}

attr Stat' IExpr BExpr Exprs Expr
    syn     names use {`S.union`} {S.empty} :: {S.Set String}
    syn     copy :: self

sem Stat'
  | Skip' IAssign' BAssign' Continue' Break'
                  lhs.init    = @label
                  lhs.final   = [@label]
                  lhs.blocks  = [CStat @copy]
                  lhs.labels  = [@label]
  | IAssign' BAssign'
                  lhs.names   = S.singleton @name
  | IfThenElse' While'
                  lhs.init    = @labelc
                     +blocks  = (:) $ CBExpr @cond.copy
                     +labels  = (:) @labelc
  | IfThenElse'      +flow    = (++) [(@labelc, @stat1.init), (@labelc, @stat2.init)]
  | While'        lhs.final   = [@labelc]
                     +flow    = (++) $ [(@labelc, @stat.init)] ++ [(x, @labelc) | x <- @stat.final]
  | Seq'             +flow    = (++) [(x, @stat2.init) | x <- @stat1.final]
                  lhs.final   = @stat2.final
                  lhs.init    = @stat1.init
  -- TODO: Implement this
  | Call'         lhs.init    = @labelCall
                  lhs.final   = [@labelExit]
                  lhs.blocks  = [CStat @copy]
                  lhs.labels  = [@labelCall, @labelExit]
                  lhs.flow    = [(@labelCall, @labelExit)] -- TODO: interprocedural stuff

sem IExpr
  | Var           lhs.names   = S.singleton @name

sem BExpr
  | BVar          lhs.names   = S.singleton @name


{
run s = wrap_Stat' (sem_Stat' s) Inh_Stat'

-- I was sorely tempted to use Template Haskell for this bit, but I thought your day might be bad enough without that.
init :: Stat' -> Int
init = init_Syn_Stat' . run

final :: Stat' -> [Int]
final = final_Syn_Stat' . run

blocks :: Stat' -> [Code]
blocks = blocks_Syn_Stat' . run

labels :: Stat' -> [Int]
labels = labels_Syn_Stat' . run

flow :: Stat' -> [(Int, Int)]
flow = flow_Syn_Stat' . run

flowR :: Stat' -> [(Int, Int)]
flowR = map (uncurry $ flip (,)) . flow

names :: Program' -> S.Set String
names prog = names_Syn_Program' $ wrap_Program' (sem_Program' prog) Inh_Program'

}
