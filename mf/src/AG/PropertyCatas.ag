module{AG.PropertyCatas}{}{}

{
import Prelude hiding (init)
import AG.AttributeGrammar
import qualified Data.Set as S
}

include "AttributeGrammar.ag"

attr Program' Proc' Stat'
    syn     init :: {Int}
    syn     final use {++} {error "undefined finals"} :: {[Int]}
    syn     labels use {++} {error "undefined labels"} :: {[Int]}

attr Procs'
    syn     labels use {++} {[]} :: {[Int]}

attr Program' Proc' Stat'
    syn     flow use {++} {[]} :: {[(Int, Int)]}

attr Program' Proc' Procs' Stat' IExpr BExpr Exprs Expr
    syn     names use {`S.union`} {S.empty} :: {S.Set String}
    syn     copy :: self

sem Program'
  | Program'      lhs.init    = @stat.init
                  lhs.final   = @stat.final

sem Procs'
  | Nil           lhs.labels  = []

sem Proc'
  | Proc'         lhs.init    = @labelEntry
                  lhs.final   = [@labelReturn]
                     +labels  = (++) [@labelEntry, @labelReturn]
                     +flow    = (++) $ [(@labelEntry, @stat.init)] ++ [(l, @labelReturn) | l <- @stat.final]

sem Stat'
  | Skip' IAssign' BAssign' Continue' Break'
                  lhs.init    = @label
                  lhs.final   = [@label]
                  lhs.labels  = [@label]
  | IAssign' BAssign'
                  lhs.names   = S.singleton @name
  | IfThenElse' While'
                  lhs.init    = @labelc
                     +labels  = (:) @labelc
  | IfThenElse'      +flow    = (++) [(@labelc, @stat1.init), (@labelc, @stat2.init)]
  | While'        lhs.final   = [@labelc]
                     +flow    = (++) $ [(@labelc, @stat.init)] ++ [(x, @labelc) | x <- @stat.final]
  | Seq'             +flow    = (++) [(x, @stat2.init) | x <- @stat1.final]
                  lhs.final   = @stat2.final
                  lhs.init    = @stat1.init
  -- TODO: Implement this
  | Call'         lhs.init    = @labelCall
                  lhs.final   = [@labelExit]
                  lhs.labels  = [@labelCall, @labelExit]
                  lhs.flow    = [(@labelCall, @labelExit)] -- TODO: interprocedural stuff

sem IExpr
  | Var           lhs.names   = S.singleton @name

sem BExpr
  | BVar          lhs.names   = S.singleton @name


{
run s = wrap_Program' (sem_Program' s) Inh_Program'

-- I was sorely tempted to use Template Haskell for this bit, but I thought your day might be bad enough without that.
init :: Program' -> Int
init = init_Syn_Program' . run

final :: Program' -> [Int]
final = final_Syn_Program' . run

labels :: Program' -> [Int]
labels = labels_Syn_Program' . run

flow :: Program' -> [(Int, Int)]
flow = flow_Syn_Program' . run

flowR :: Program' -> [(Int, Int)]
flowR = map (uncurry $ flip (,)) . flow

names :: Program' -> S.Set String
names prog = names_Syn_Program' $ wrap_Program' (sem_Program' prog) Inh_Program'

}
