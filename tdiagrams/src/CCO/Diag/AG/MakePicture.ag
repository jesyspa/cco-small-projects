imports
{
import CCO.Diag.Figure
import CCO.Picture.AG
}

include "Base.ag"

-- U stands for "use", P stands for "provide"
-- Programs, interpreters, and compilers use running connections
-- Interpreters and platforms provide running connections
-- Programs and interpreters use compilation connections
-- Compilers provide compilation connections
-- Compilation connections involve two points: the connection to use for
-- to start the compilation and the connection to use to end it

type MPoint = maybe Point
type PointPair = (Point, Point)
type MPointPair = maybe PointPair

attr Diag Diag_
    syn runU        :: MPoint
    syn runP        :: MPoint
    syn comU        :: MPointPair
    syn comP        :: MPointPair
    syn code        :: Commands

{
todoPoint :: Point
todoPoint = undefined
}

sem Diag_
    | Program       lhs.runU        = rUProgram
                       .runP        = 0
                       .comU        = cUProgram
                       .comP        = 0
    | Platform      lhs.runU        = 0
                       .runP        = rPPlatform
                       .comU        = 0
                       .comP        = 0
    | Interpreter   lhs.runU        = rUInterpreter
                       .runP        = rPInterpreter
                       .comU        = cUInterpreter
                       .comP        = 0
    | Compiler      lhs.runU        = rUCompiler
                       .runP        = 0
                       .comU        = cUCompiler
                       .comP        = cPCompiler
    | Execute       lhs.runU        = undefined
                       .runP        = undefined
                       .comU        = undefined
                       .comP        = undefined
    | Compile       lhs.runU        = undefined
                       .runP        = undefined
                       .comU        = undefined
                       .comP        = undefined

sem Diag_
    | Program       lhs.code = []
    | Platform      lhs.code = []
    | Interpreter   lhs.code = []
    | Compiler      lhs.code = []
    | Execute       lhs.code = map (translateMany @loc.d1trans) @d1.code ++ map (translateMany @loc.d2trans) @d2.code
                    loc.d1trans = undefined
                    loc.d2trans = undefined
    | Compile       lhs.code = map (translateMany @loc.d1transL) @d1.code ++ map (translateMany @loc.d2trans) @d2.code ++ map (translateMany @loc.d1transR) @d1.code
                    loc.d1transL = undefined
                    loc.d1transR = undefined
                    loc.d2trans = undefined


{
translateMany :: Point -> Command -> Command
translateMany = undefined


}
