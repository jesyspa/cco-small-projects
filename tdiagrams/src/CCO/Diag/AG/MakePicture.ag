imports
{
import CCO.Diag.Figure
import CCO.Picture.AG
}

include "Base.ag"

-- U stands for "use", P stands for "provide"
-- Programs, interpreters, and compilers use running connections
-- Interpreters and platforms provide running connections
-- Programs and interpreters use compilation connections
-- Compilers provide compilation connections
-- Compilation connections involve two points: the connection to use for
-- to start the compilation and the connection to use to end it

type PointPair = (Point, Point)

attr Diag Diag_
    syn runU        :: Point
    syn runP        :: Point
    syn comU        :: PointPair
    syn comP        :: PointPair
    syn code        :: Commands

{
todoPoint :: Point
todoPoint = undefined

todoPointPair :: PointPair
todoPointPair = undefined
}

sem Diag_
    | Program       lhs.runU        = todoPoint
                       .runP        = error "invalid input"
                       .comU        = todoPointPair
                       .comP        = error "invalid input"
    | Platform      lhs.runU        = error "invalid input"
                       .runP        = todoPointPair
                       .comU        = error "invalid input"
                       .comP        = error "invalid input"
    | Interpreter   lhs.runU        = todoPoint
                       .runP        = todoPoint
                       .comU        = todoPointPair
                       .comP        = error "invalid input"
    | Compiler      lhs.runU        = todoPoint
                       .runP        = error "invalid input"
                       .comU        = todoPointPair
                       .comP        = todoPointPair
    | Execute       lhs.runU        = translate @loc.d2trans @d2.runU
                       .runP        = translate @loc.d1trans @d1.runP
                       .comU        = translate @loc.d2trans @d2.comU
                       .comP        = translate @loc.d1trans @d1.comP
    | Compile       lhs.runU        = translate @loc.d1transR @d1.runU
                       .runP        = translate @loc.d1transR @d1.runP
                       .comU        = translate @loc.d1transR @d1.comU
                       .comP        = translate @loc.d1transR @d1.comP

sem Diag_
    | Program       lhs.code = []
    | Platform      lhs.code = []
    | Interpreter   lhs.code = []
    | Compiler      lhs.code = []
    | Execute       lhs.code = map (translateCmd @loc.d1trans) @d1.code ++ @d2.code
                    loc.d1trans = @d2.runP |-| @d1.runU
    | Compile       lhs.code = map (translateCmd @loc.d1transL) @d1.code ++ @d2.code ++ map (translateCmd @loc.d1transR) @d1.code
                    loc.d1transL = fst @d1.comU |-| fst @d2.comP
                    loc.d1transR = snd @d1.comU |-| snd @d2.comP


{
translateCmd :: Point -> Command -> Command
translateCmd p (Put pos obj) = Put (translate pos) obj
}

