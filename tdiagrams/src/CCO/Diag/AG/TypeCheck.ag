imports
{
import Data.Maybe
import CCO.SourcePos
import CCO.Diag.TypeError
import Control.Monad
import Debug.Trace
}

-------------------------------------------------------------------------------
-- Type Checking
-------------------------------------------------------------------------------

type Translation = (Implementation, Implementation)
type MImpl = maybe Implementation
type MTrans = maybe Translation
type Errors = [ TypeError ]
type ErrorsAnn = [ TypeErrorAnn ]

attr Diag Diag_
  syn canRunOn            :: MImpl
  syn canRun              :: MImpl
  syn canCompile          :: MTrans
  syn errMsg              :: Errors
  syn err use {(++)} {[]} :: ErrorsAnn

sem Diag
  | Diag              +err = (++) $ map (TypeErrorAnn @pos) @d.errMsg

sem Diag_
  | Execute           lhs.errMsg = connectExec @d1.canRunOn @d2.canRun
  | Compile           lhs.errMsg = connectComp @d1.canRunOn (fst <$> @d2.canCompile)
  | Program           lhs.errMsg = []
  | Platform          lhs.errMsg = []
  | Interpreter       lhs.errMsg = []
  | Compiler          lhs.errMsg = []

sem Diag_
  | Program           lhs.canRunOn = Just @l
  | Platform          lhs.canRunOn = Nothing
  | Interpreter       lhs.canRunOn = Just @m
  | Compiler          lhs.canRunOn = Just @m
  | Execute           lhs.canRunOn = @d2.canRunOn
  | Compile           lhs.canRunOn = snd <$> @d2.canCompile

sem Diag_
  | Program           lhs.canRun = Nothing
  | Platform          lhs.canRun = Just @m
  | Interpreter       lhs.canRun = Just @l
  | Compiler          lhs.canRun = Nothing
  | Execute           lhs.canRun = @d1.canRun
  | Compile           lhs.canRun = @d1.canRun

sem Diag_
  | Program           lhs.canCompile = Nothing
  | Platform          lhs.canCompile = Nothing
  | Interpreter       lhs.canCompile = Nothing
  | Compiler          lhs.canCompile = Just (@l1, @l2)
  | Execute           lhs.canCompile = @d1.canCompile
  | Compile           lhs.canCompile = @d1.canCompile

-------------------------------------------------------------------------------
-- Utilities
-------------------------------------------------------------------------------

{
type Implementation = String

ifNothing :: Maybe a -> b -> [b]
ifNothing (Just _) _ = []
ifNothing Nothing b = [b]

connectExec :: MImpl -> MImpl -> Errors
connectExec (Just x) (Just y) | x == y = []
                              | otherwise = return $ RuntimeMismatch x y
connectExec a b = ifNothing a CannotBeRun ++ ifNothing b CannotRun

connectComp :: MImpl -> MImpl -> Errors
connectComp (Just x) (Just y) | x == y = []
                              | otherwise = return $ CompilerMismatch x y
connectComp a b = ifNothing a CannotBeCompiled ++ ifNothing b CannotCompile

-- Test code moved to example/double_compile.tdg

test x = err_Syn_Diag (wrap_Diag (sem_Diag x) $ Inh_Diag)

-- typeExp = print (show result)
}
