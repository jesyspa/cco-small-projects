imports
{
import Data.Maybe
import Control.Monad
import Debug.Trace
}

-------------------------------------------------------------------------------
-- Type Checking
-------------------------------------------------------------------------------

type Translation = (Implementation, Implementation)
type MImpl = maybe Implementation
type MTrans = maybe Translation
type Errors = [ TypeError ]

attr Diag Diag_
  syn canRunOn            :: MImpl
  syn canRun              :: MImpl
  syn canCompile          :: MTrans
  syn err use {(++)} {[]} :: Errors

sem Diag_
  | Execute           +err = (++) $ connect @d1.canRunOn @d2.canRun
  | Compile           +err = (++) $ connect @d1.canRunOn (fst <$> @d2.canCompile)

sem Diag_
  | Program           lhs.canRunOn = Just @l
  | Platform          lhs.canRunOn = Nothing
  | Interpreter       lhs.canRunOn = Just @m
  | Compiler          lhs.canRunOn = Just @m
  | Execute           lhs.canRunOn = @d2.canRunOn
  | Compile           lhs.canRunOn = snd <$> @d2.canCompile

sem Diag_
  | Program           lhs.canRun = Nothing
  | Platform          lhs.canRun = Just @m
  | Interpreter       lhs.canRun = Just @l
  | Compiler          lhs.canRun = Nothing
  | Execute           lhs.canRun = @d1.canRun
  | Compile           lhs.canRun = @d1.canRun

sem Diag_
  | Program           lhs.canCompile = Nothing
  | Platform          lhs.canCompile = Nothing
  | Interpreter       lhs.canCompile = Nothing
  | Compiler          lhs.canCompile = Just (@l1, @l2)
  | Execute           lhs.canCompile = @d1.canCompile
  | Compile           lhs.canCompile = @d1.canCompile

-------------------------------------------------------------------------------
-- Utilities
-------------------------------------------------------------------------------

{
type Implementation = String
type Language = String
type Platform = String

connect :: MImpl -> MImpl -> [TypeError]
connect (Just x) (Just y) | x == y    = []
                          | otherwise = [GenericError $ "type mismatch: " ++ x ++ " vs " ++ y]
connect (Just x) Nothing              = [GenericError $ "trying to do something with " ++ x ++ " and nothing"]
connect Nothing (Just y)              = [GenericError $ "trying to do something with nothing and " ++ y]
connect Nothing Nothing               = [GenericError ""]

data TypeError = GenericError String
               deriving (Eq, Ord, Read, Show)

testDiag :: Diag
testDiag = Diag (undefined) (Execute (Diag (undefined) (Program "hello" "haskell")) (Diag (undefined) (Platform "osx")))

simpleDiag = Diag (undefined) (Program "hello" "haskell")

root = sem_Diag testDiag

result = err_Syn_Diag (wrap_Diag root $ Inh_Diag)

typeExp = print (show result)
}
