imports
{
import CCO.Diag.DiagType
import Data.Maybe
}

-------------------------------------------------------------------------------
-- Type Checking
-------------------------------------------------------------------------------


attr Diag Diag_
  syn tp     :: self

attr Diag_
  syn err :: {Maybe TypeError}
  inh ti :: DiagType


sem Diag_
  | Program           lhs.err = Nothing
  | Platform          lhs.err = Nothing
  | Interpreter       lhs.err = Nothing
  | Compiler          lhs.err = Nothing
  | Execute           lhs.err = isExecutable (unWrap @d1.tp) (unWrap @d2.tp)
  | Compile           lhs.err = isCompilable (unWrap @d1.tp) (unWrap @d2.tp)

sem Diag_
  | Execute           @d1.ti = runsOn (unWrap @d2.tp)
                      @d2.ti = wantsToRun (unWrap @d1.tp)
  | Compile           @d1.ti = nullType
                      @d2.ti = nullType
-------------------------------------------------------------------------------
-- Utilities
-------------------------------------------------------------------------------

{
type Language = String
type Platform = String

unWrap :: Diag -> Diag_
unWrap (Diag pos d) = d

runsOn :: Diag_ -> DiagType
runsOn (Platform p m) = nullType {canRun = Just m}
runsOn (Interpreter i l m) = nullType {canRun = Just l}
runsOn (Compiler c l1 l2 m) = nullType {canRun = Just l}


equalOrError :: (String, String) -> TypeError -> Maybe TypeError
equalOrError (s1, s2) e = if s1 == s2 then Nothing else Just e

isExecutable :: Diag_ -> Diag_ -> Maybe TypeError
isExecutable (Program p l) (Interpreter i l' m) = (l, l') `equalOrError` (GenericError $ "Type mismatch. " ++ l ++ l')
isExecutable (Interpreter i l m) (Platform m') = (m, m') `equalOrError` (GenericError $ "Type mismatch. " ++ m ++ m')
isExecutable (Compiler i l1 l2 m) (Platform m') = (m, m') `equalOrError` (GenericError $ "Type mismatch. " ++ m ++ m')
isExecutable (Execute d1 d2) _ = isExecutable (unWrap d1) (unWrap d2)
isExecutable (Compile d1 d2) _ = isExecutable (unWrap d1) (unWrap d2)
isExecutable _ _ = Just $ GenericError "Nonsense"

isCompilable :: Diag_ -> Diag_ -> Maybe TypeError
isCompilable (Program p l) (Compiler c l' l'' m) = (l, l') `equalOrError` (GenericError $ "Type mismatch. " ++ l ++ l')
isCompilable (Interpreter i l m) (Compiler c l' l'' m') = (m, m') `equalOrError` (GenericError $ "Type mismatch. " ++ m ++ m')
isCompilable (Compiler i l l2 m) (Compiler c l' l2' m') = (m, m') `equalOrError` (GenericError $ "Type mismatch. " ++ m ++ m')
isCompilable _ _ = Just $ GenericError "Nonsense"
}
