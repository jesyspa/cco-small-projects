module {CCO.BNormal.AG.ToCore}{}{}
{
import CCO.BNormal.AG.BNormal
import CCO.BNormal.Context
import qualified CCO.Core.AG.Base as C
}

include "BNormal.ag"

-- Convert a rooted BNormal term to a Core module.

attr BTm BExp BVal BVals BBind Binding Bindings
  -- The bindings available at the value being converted.
  inh context :: {Context}

attr BVal
  -- The resulting code.
  -- idem. for all other 'code' attributes.
  syn code :: {C.SExp}

attr BVals
  syn code use {:} {[]} :: {[C.SExp]}

attr BRoot
  syn code :: {C.Mod}

attr BTm BExp BBind
  syn code :: {C.Exp}

attr Bindings
  syn code use {:} {[]}:: {[C.Bind]}
  -- A list of variables bound by these bindings.
  syn boundVars use {:} {[]} :: {[Var]}

attr Binding
  syn code use {++} {[]}:: {C.Bind}
  -- The variable bound by this binding.
  --
  -- The plural is necessary to make UUAG autogenerate code for 'Bindings'.
  syn boundVars :: {Var}

sem BRoot
  | BRoot  lhs.code        = C.Mod @b.code []
           b  .context     = newContext

sem BVal
  | BNat   lhs.code        = C.Int @i
  | BVar   lhs.code        = C.Var $ resolve @lhs.context @x
  | BField lhs.code        = C.Var $ C.Field (resolve @lhs.context @x) @i

sem BExp
  | BVal   lhs.code        = C.SExp @v.code
  | BApp   lhs.code        = C.App (C.SExp $ C.Var $ resolve @lhs.context @x1) [C.Var $ resolve @lhs.context @x2]
  | BLam   loc.context     = pushFrame [@x] @lhs.context
           lhs.code        = C.Lam [resolve @loc.context @x] @b.code
           b  .context     = @loc.context
  | BAlloc lhs.code        = C.Node @tag @vs.code
  | BPrim  lhs.code        = C.Prim @op @vs.code
  | BWrap  lhs.code        = C.Lam [] @b.code
           b  .context     = pushFrame [] @lhs.context
  | BForce lhs.code        = C.Eval @e.code
  | BTail  lhs.code        = C.Tail @e.code

sem BTm
  | BIf    -- The order is flipped here, since b2 corresponds to False (0) and b1 corresponds to True (1)
           lhs.code        = C.Case (C.Var $ C.Tag $ resolve @lhs.context @x) [@b2.code, @b1.code]

sem BBind
  | BBind  loc.context     = appendToFrame @es.boundVars @lhs.context
           lhs.code        = foldr C.Let @t.code @es.code
           t  .context     = @loc.context
           es .context     = @loc.context

sem Binding
  | Tuple  lhs.code        = C.Bind (resolve @lhs.context @x1) @x2.code
           lhs.boundVars   = @x1

