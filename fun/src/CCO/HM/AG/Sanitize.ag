module{CCO.HM.AG.Sanitize}{}{}
imports
{
import CCO.HM.AG.BaseHelpers
import CCO.HM.AG.Base
import CCO.HM.Builtins (builtinMarkedNames)
import CCO.HM.TmSymbolTable
import Data.Maybe
import Data.List
}

include "Base.ag"

attr Root Tm_ Tm
  syn code :: self

attr Root
  syn unresolved :: {[(Var, SourcePos)]}

attr Tm Tm_
  chn context :: {TMSTable}

attr Tm_
  inh pos :: {SourcePos}

sem Root
  | Root  tm .context    = foldr ($) empty $ map (uncurry specialBind) builtinMarkedNames
          lhs.unresolved = unresolved @tm.context

sem Tm
  | Tm    t  .pos        = @pos

sem Tm_
  | Var   loc.result     = use @x @lhs.pos @lhs.context
          lhs.code       = Var $ fst @loc.result
          lhs.context    = snd @loc.result
  | Lam   loc.result     = bind @x (enterScope @lhs.context)
          t1 .context    = snd @loc.result
          lhs.code       = Lam (fst @loc.result) @t1.code
          lhs.context    = leaveScope @t1.context
  | Let   loc.result     = bind @x @lhs.context
          lhs.code       = Let (fst @loc.result) @t1.code @t2.code
          t1 .context    = enterScope $ snd @loc.result
          t2 .context    = leaveScope @t1.context
          lhs.context    = release @t2.context
  | Prim  loc.result     = stateMapM (\x -> use x @lhs.pos) @args @lhs.context
          lhs.code       = Prim @op (fst @loc.result)
          lhs.context    = snd @loc.result

{
stateMapM :: (a -> s -> (b, s)) -> [a] -> s -> ([b], s)
stateMapM f = foldr (\a r s -> let (b, s') = f a s; (bs, s'') = r s' in (b:bs, s'')) (\s -> ([], s))

}

