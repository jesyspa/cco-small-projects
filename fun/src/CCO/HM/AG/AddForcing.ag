module{CCO.HM.AG.AddForcing}{}{}
imports
{
import CCO.HM.AG.BaseHelpers
import CCO.HM.AG.BNormal
import CCO.HM.AG.BNormalUtils
import Data.Maybe
import Data.List
}

include "BNormal.ag"

attr BRoot BTm BBind BExp BVal BVals Binding Bindings
  syn code :: self

attr BTm BBind BExp BVal BVals Binding Bindings
  chn counter :: Int

attr BExp BTm BBind
  inh forced :: {Bool}

attr BExp BTm
  syn bindings use {++} {[]} :: {[(Var, BExp)]}

sem BRoot
  | BRoot   b  .forced    = True
            b  .counter   = 0

sem BExp
  | BVal    +code         = maybeForce @lhs.forced
  | BApp    +code         = maybeForce @lhs.forced
  | BLam    b  .forced    = True
  | BPrim   loc.num       = @lhs.counter
            lhs.counter   = @loc.num + length @vs.code
            loc.args'     = zip (map forcedVar [@loc.num..]) @vs.code
            lhs.code      = BPrim @op $ map (BVar . fst) @loc.args'
            lhs.bindings  = map (\(v, v') -> (v, BForce $ BVal v')) @loc.args'

sem BTm
  | BIf     loc.num :: uniqueref counter
            loc.fvar      = forcedVar @loc.num
            lhs.code      = BIf @loc.fvar @b1.code @b2.code
            lhs.bindings  = [(@loc.fvar, BForce $ BVal $ BVar @x)]

sem BBind
  | BBind   +code         = extendBind @t.bindings

sem Binding
  | Tuple   x2 .forced    = False


{
forcedVar :: Int -> Var
forcedVar i = "$f_" ++ show i

maybeForce :: Bool -> BExp -> BExp
maybeForce True = BForce
maybeForce False = id

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)
}
