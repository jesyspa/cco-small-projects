module{CCO.HM.AG.AddForcing}{}{}
imports
{
import CCO.HM.AG.BaseHelpers
import CCO.HM.AG.ANormal
import CCO.HM.AG.ANormalUtils
import Data.Maybe
import Data.List
}

include "ANormal.ag"

attr AVal AVals AExp ATm
  syn code :: self

attr AExp ATm
  chn counter :: Int
  inh forced :: {Bool}

attr AExp
  syn bindings use {++} {[]} :: {[(Var, AExp)]}

sem AExp
  | AVal    lhs.code      = maybeForce @lhs.forced $ AVal @v.code
  | AApp    lhs.code      = maybeForce @lhs.forced $ AApp @e.code @v.code
            v  .forced    = False
  | ALam    lhs.code      = ALam @xs @t.code
            t  .forced    = True
  | AAlloc  lhs.code      = AAlloc @tag @vs.code
  | APrim   loc.num       = @lhs.counter
            lhs.counter   = @loc.num + length @vs.code
            loc.args'     = zip (map forcedVar [@loc.num..]) @vs.code
            lhs.code      = APrim @op $ map (AVar . fst) @loc.args'
            lhs.bindings  = map (\(v, v') -> (v, AForce $ AVal v')) @loc.args'
  | AForce  lhs.code      = AForce @e.code

sem ATm
  | AExp    lhs.code      = wrapBinds' @e.code @e.bindings
  | ALet    lhs.code      = wrapBinds (ALet @x @e.code @t.code) @e.bindings
  | AIf     loc.num :: uniqueref counter
            loc.fvar      = forcedVar @loc.num
            lhs.code      = ALet @loc.fvar (AForce $ AVal @c.code) $ AIf (AVar @loc.fvar) @t1.code @t2.code


{
forcedVar :: Int -> Var
forcedVar i = "$f_" ++ show i

maybeForce :: Bool -> AExp -> AExp
maybeForce True = AForce
maybeForce False = id

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)
}
