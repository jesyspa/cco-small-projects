module {CCO.HM.AG.HmCore}{}{}
{
import CCO.HM.AG.BaseHelpers
import CCO.HM.AG.ANormal
import CCO.HM.Context
import qualified CCO.Core.AG.Base as C
}

include "ANormal.ag"

attr ATm AExp AVal AVals
  inh context :: {Context}
  -- Really, we'd like to specify that we only care about tagPosition in the case of AVals.  However, that's not
  -- practical because then we have to specify it on all values, while it's actually only very rarely true.
  inh tagPosition :: {Bool}

attr AVal
  syn code :: {C.SExp}

attr AVals
  syn code use {:} {[]} :: {[C.SExp]}

attr ATm AExp
  syn code :: {C.Exp}

attr ATm
  syn bindings use {++} {[]} :: {[C.Bind]}

sem AVal
  | ANat   lhs.code        = C.Int @i
  | AVar   lhs.code        = C.Var $ (if @lhs.tagPosition then C.Tag else id) $ resolve @x @lhs.context
  | AField lhs.code        = C.Var $ C.Field (resolve @x @lhs.context) @i

sem AExp
  | AVal   lhs.code        = C.SExp @v.code
  | AApp   lhs.code        = C.App @e.code [@v.code]
  | ALam   loc.context     = foldr push (pushFrame @lhs.context) (reverse @xs)
           lhs.code        = C.Lam (map (\x -> resolve x @loc.context) @xs) @t.code
  | AIf    c  .tagPosition = True
           -- The order is flipped here, since t2 corresponds to False (0) and t1 corresponds to True (1)
           lhs.code        = C.Case @c.code [@t2.code, @t1.code]
  | AAlloc lhs.code        = C.Node @t @vs.code
  | APrim  lhs.code        = C.Prim @op @vs.code

sem ATm
  | ALet   lhs.code        = @t.code
           t  .context     = @loc.context
           loc.context     = push @x @lhs.context
           lhs.bindings    = [C.Bind (resolve @x @loc.context) @e.code] ++ @t.bindings

