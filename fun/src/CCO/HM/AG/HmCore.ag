module {CCO.HM.AG.HmCore}{}{}
{
import CCO.HM.AG.BaseHelpers
import CCO.HM.AG.ANormal
import CCO.HM.Context
import qualified CCO.Core.AG.Base as C
}

include "ANormal.ag"

attr ATm AExp AVal AVals
  inh context :: {Context}

attr AVal
  syn code :: {C.SExp}

attr AVals
  syn code use {:} {[]} :: {[C.SExp]}

attr ARoot
  syn code :: {C.Mod}

attr ATm AExp
  syn code :: {C.Exp}
  syn locals use {++} {[]} :: {[Var]}

sem ARoot
  | ARoot  t  .context     = newContext @t.locals
           lhs.code        = C.Mod @t.code []

sem AVal
  | ANat   lhs.code        = C.Int @i
  | AVar   lhs.code        = C.Var $ resolve @lhs.context @x
  | ATag   lhs.code        = C.Var $ C.Tag $ resolve @lhs.context @x
  | AField lhs.code        = C.Var $ C.Field (resolve @lhs.context @x) @i

sem AExp
  | AVal   lhs.code        = C.SExp @v.code
  | AApp   lhs.code        = C.App @e.code [@v.code]
  | ALam   loc.context     = pushFrame @loc.locals @lhs.context
           loc.locals      = @xs ++ @t.locals
           lhs.locals      = []
           lhs.code        = C.Lam (map (resolve @loc.context) @xs) @t.code
  | AAlloc lhs.code        = C.Node @tag @vs.code
  | APrim  lhs.code        = C.Prim @op @vs.code
  | AForce lhs.code        = C.Eval @e.code
  | ATail  lhs.code        = C.Tail @e.code

sem ATm
  | ALet   lhs.code        = C.Let (C.Bind (resolve @lhs.context @x) @e.code) @t.code
           lhs.locals      = @x : @t.locals
  | AIf    -- The order is flipped here, since t2 corresponds to False (0) and t1 corresponds to True (1)
           lhs.code        = C.Case @c.code [@t2.code, @t1.code]
           t1 .context     = appendToFrame @t1.locals @lhs.context
           t2 .context     = appendToFrame @t2.locals @lhs.context
           lhs.locals      = []

