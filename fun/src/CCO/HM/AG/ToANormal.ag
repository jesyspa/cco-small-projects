module{CCO.HM.AG.ToANormal}{}{}
imports
{
import CCO.HM.AG.BaseHelpers
import CCO.HM.AG.Base
import CCO.HM.AG.ANormal
}

include "Base.ag"

attr Tm_ Tm
  syn code :: {AExp}
  syn bindings use {++} {[]} :: {[(Var, AExp)]}
  chn counter :: Int

sem Tm_
  | Nat   lhs.code      = AVal $ ANat  @i
  | Var   lhs.code      = AVal $ AVar  @x
  | Lam   lhs.code      = ALam [@x] $ wrapBinds @t1.code @t1.bindings
          lhs.bindings  = []
  -- The next case is unfinished.  We should extend the bindings if v @t2.code isn't a simple value
  | App   lhs.code      = AApp @t1.code (AVar @loc.fresh)
          loc.num :: uniqueref counter
          loc.fresh     = "$e_" ++ show @loc.num
          +bindings     = (:) (@loc.fresh, @t2.code)
  | Let   lhs.code      = @t2.code
          lhs.bindings  = @t2.bindings ++ [(@x, @t1.code)] ++ @t1.bindings
  | If    loc.c1        = wrapBinds @t1.code @t1.bindings
          loc.c2        = wrapBinds @t2.code @t2.bindings
          loc.num :: uniqueref counter
          loc.fresh     = "$e_" ++ show @loc.num
          lhs.code      = AIf (AVar @loc.fresh) @loc.c1 @loc.c2
          lhs.bindings  = [(@loc.fresh, @c.code)] ++ @c.bindings

{
wrapBinds :: AExp -> [(Var, AExp)] -> ATm
wrapBinds e = foldr (uncurry ALet) (AExp e) . reverse

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)
}

