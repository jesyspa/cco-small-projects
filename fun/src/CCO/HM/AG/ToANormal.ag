module{CCO.HM.AG.ToANormal}{}{}
imports
{
import CCO.HM.AG.BNormal
import CCO.HM.AG.ANormal
import CCO.HM.AG.ANormalUtils
import CCO.HM.Builtins
import Data.List
}

include "BNormal.ag"

attr BTm BBind BExp BVal BVals Binding Bindings
  syn freevars use {`union`} {[]} :: {[Var]}

attr BVal
  syn code :: {AVal}

attr BVals
  syn code use {:} {[]} :: {AVals}

attr BExp
  syn code :: {AExp}

attr BTm BBind
  syn code :: {ATm}

attr BRoot
  syn code :: {ARoot}

attr Binding Bindings
  syn code use {++} {[]} :: {[(Var, AExp)]}

sem BRoot
  | BRoot   lhs.code      = ARoot $ wrapBinds @b.code $ filter (flip elem @b.freevars . fst) builtins

sem BVal
  | BNat    lhs.code      = ANat @i
  | BVar    lhs.code      = AVar @x
            lhs.freevars  = [@x]

sem BExp
  | BVal    lhs.code      = AVal @v.code
  | BApp    lhs.code      = AApp (AVal @v1.code) @v2.code
  | BLam    lhs.code      = ALam [@x] @b.code
            +freevars     = delete @x
  | BPrim   lhs.code      = APrim @op @vs.code
  | BWrap   lhs.code      = AForce $ ALam [] @b.code

sem BBind
  | BBind   lhs.code      = foldr (uncurry ALet) @t.code (reverse @es.code)
            +freevars     = flip (\\) $ fmap fst @es.code

sem BTm
  | BExp    lhs.code      = AExp @e.code
  | BIf     lhs.code      = AIf @c.code @b1.code @b2.code

sem Binding
  | Tuple   lhs.code      = [(@x1, @x2.code)]
