module{CCO.HM.AG.ToANormal}{}{}
imports
{
import CCO.HM.AG.BaseHelpers
import CCO.HM.AG.Base
import CCO.HM.AG.ANormal
import Data.List
}

include "Base.ag"

attr Tm_ Tm Tms
  syn bindings use {++} {[]} :: {[(Var, AExp)]}
  chn counter :: Int
  syn freevars use {`union`} {[]} :: {[Var]}

attr Tm_ Tm
  syn code :: {AExp}

attr Tms
  syn code use {:} {[]} :: {[AExp]}

sem Tm_
  | Nat   lhs.code      = AVal $ ANat  @i
  | Var   lhs.code      = AVal $ AVar  @x
          lhs.freevars  = [@x]
  | Lam   lhs.code      = ALam [@x] $ wrapBinds @t1.code @t1.bindings
          lhs.bindings  = []
          +freevars     = delete @x
  | App   lhs.code      = AApp @t1.code (AVar @loc.fresh)
          loc.num :: uniqueref counter
          loc.fresh     = "$e_" ++ show @loc.num
          +bindings     = (:) (@loc.fresh, @t2.code)
  | Let   lhs.code      = @t2.code
          lhs.bindings  = @t2.bindings ++ [(@x, @t1.code)] ++ @t1.bindings
          +freevars     = delete @x
  | If    loc.c1        = wrapBinds @t1.code @t1.bindings
          loc.c2        = wrapBinds @t2.code @t2.bindings
          loc.num :: uniqueref counter
          loc.fresh     = "$e_" ++ show @loc.num
          lhs.code      = AIf (AVar @loc.fresh) @loc.c1 @loc.c2
          lhs.bindings  = [(@loc.fresh, @c.code)] ++ @c.bindings
  -- Convert to ANormal form.
  | Prim  lhs.code      = APrim @op (map AVar @args)
          lhs.freevars  = @args

{
wrapBinds :: AExp -> [(Var, AExp)] -> ATm
wrapBinds e = foldr (uncurry ALet) (AExp e) . reverse

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)
}

